#!/usr/bin/env python


import subprocess
import sys
import os.path
import os
import signal

def get_postfix(platform):
    if platform == 'win32':
        return '.exe'
    elif platform == 'darwin':
        return '.app'
    else:
        return ''

PRJ_NAME_BASE = "UnitTests"
PRJ_POSTFIX = get_postfix(sys.platform)
PRJ_NAME = PRJ_NAME_BASE + PRJ_POSTFIX

DAVA_ROOT   = '@DAVA_ROOT_DIR@'
DAVA_APP_DIR = '@CMAKE_BINARY_DIR@/app'
DAVA_APP_OTHER_DIR = '@CMAKE_BINARY_DIR@/app_other'
DAVA_BUILD_DIR = '@CMAKE_BINARY_DIR@'

start_on_android = False
start_on_ios = False
start_on_uwp = False

run_at_teamcity = True

cmake_platform = '@DAVA_PLATFORM_CURRENT@'

if cmake_platform == "ANDROID":
    start_on_android = True
elif cmake_platform == "IOS":
    start_on_ios = True
elif cmake_platform == "WINUAP":
    start_on_uwp = True

sub_process = None

def __execute(param) :

    sub_process = subprocess.Popen(param, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    subProcessContinue = True

    while subProcessContinue:
        try:
            line = sub_process.stdout.readline()
            sys.stdout.write(line)
            sys.stdout.flush()
            if line == '':
                subProcessContinue = False
                continue
        except IOError as err:
            sys.stdout.write(err.message)
            sys.stdout.flush()


def start_self_tests():

    os.chdir( DAVA_APP_DIR )

    sys.stdout.write("##teamcity[testStarted name=\'Self test ResourceEditor test\']\n")
    sys.stdout.flush()
    if sys.platform == 'win32' and start_on_uwp == False:
        __execute( ['ResourceEditor.exe','--selftest'] )

    elif sys.platform == "darwin" and start_on_ios == False:
        __execute( [os.path.join ('ResourceEditor.app','Contents', 'MacOS','ResourceEditor'),'--selftest'] )
##
    sys.stdout.write("##teamcity[testStarted name=\'Self test QuickEd test\']\n")
    sys.stdout.flush()

    if sys.platform == 'win32' and start_on_uwp == False:
        __execute( ['QuickEd.exe','--selftest'] )

    elif sys.platform == "darwin" and start_on_ios == False:
        __execute( [os.path.join ( 'QuickEd.app','Contents', 'MacOS','QuickEd'),'--selftest'] )

def start_unittests_on_android_device():
    global sub_process
    # if screen turned off
    device_state = subprocess.check_output(['adb', 'shell', 'dumpsys', 'power'])
    if device_state.find("mScreenOn=false") != -1:
        # turn screen on
        subprocess.check_call(['adb', 'shell', 'input', 'keyevent', '26'])
    # unlock device screen
    subprocess.check_call(['adb', 'shell', 'input', 'keyevent', '82'])
    # clear log before start tests
    subprocess.check_call(["adb", "logcat", "-c"])
    # start adb logcat and gather output DO NOT filter by TeamcityOutput tag
    # because we need interrupt gather log when unittests process finished
    sub_process = subprocess.Popen(
        ["adb", "logcat", "-s", "TeamcityOutput", "AndroidRuntime:E", "ActivityManager:W"],
        stdout=subprocess.PIPE)
    # start unittests on device
    commandLine = ["adb", "shell", "am", "start", "-n", "com.dava.unittests/com.dava.engine.DavaActivity"]
    if run_at_teamcity == True:
        commandLine.extend(["-es", "-teamcity"]) 

    subprocess.Popen(commandLine)
    return sub_process

def start_unittests_on_uwp_device():
    global sub_process
    name = []

    for root, dirs, files in os.walk(DAVA_APP_OTHER_DIR):
        for file in files:
            if file.endswith(".appxbundle") and PRJ_NAME_BASE in file:
                 name.append(os.path.join(root, file))

    package_name = name[0]
    arch = sys.argv[2]

    uwp_runner_path = os.path.join (DAVA_ROOT, 'Bin','UWPRunner.exe' )

    commandLine = [uwp_runner_path, 
                                    '--package', package_name, 
                                    '--arch', arch,
                                    '--tc_test', '--dava_app']
    if run_at_teamcity == True:
        commandLine.extend(['--cmd_line', '-teamcity']) 

    sub_process = subprocess.Popen(commandLine, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    
    return sub_process

##start self tests
start_self_tests()


##start unit tests

if start_on_ios:
    app_path = os.path.join (DAVA_APP_OTHER_DIR, PRJ_NAME )
    ios_deploy_path = os.path.join (DAVA_ROOT, 'Programs','UnitTests','Scripts','ios-deploy' )

    commandLine = [ios_deploy_path, "-d", "--noninteractive", "-b", app_path]
    if run_at_teamcity == True:
        commandLine.extend(["-a", "-teamcity"]) 

    sub_process = subprocess.Popen(commandLine, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    print("copy " + PRJ_NAME_BASE + PRJ_POSTFIX + " on device and run")
elif start_on_android:
    sub_process = start_unittests_on_android_device()
elif sys.platform == 'win32' and start_on_uwp == False:

    app_path = os.path.join (DAVA_APP_OTHER_DIR, PRJ_NAME )

    commandLine = [ app_path ]

    if run_at_teamcity == True:
        commandLine.extend(["-teamcity"])

    sub_process = subprocess.Popen(commandLine, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


elif sys.platform == 'win32' and start_on_uwp == True:
    # run appx to Win10 device
    sub_process = start_unittests_on_uwp_device()

elif sys.platform == "darwin":

    app_path = os.path.join (DAVA_APP_OTHER_DIR, PRJ_NAME, 'Contents', 'MacOS', PRJ_NAME_BASE )

    commandLine = [app_path]
    if run_at_teamcity == True:
        commandLine.extend(["-teamcity"])

    sub_process = subprocess.Popen(commandLine, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

app_exit_code = 0

continue_process_stdout = True

while continue_process_stdout:
    try:
        line = sub_process.stdout.readline()
        if line != '':
            teamcity_line_index = line.find("##teamcity")
            if teamcity_line_index != -1:
                teamcity_line = line[teamcity_line_index:]
                sys.stdout.write(teamcity_line)
                sys.stdout.flush()
            if line.find("Finish all tests.") != -1:    # this text marker helps to detect good \
                                                        #  finish tests on ios device (run with lldb)
                if start_on_android:
                    # we want to exit from logcat process because sub_process.stdout.readline() will block
                    # current thread
                    if sys.platform == "win32":
                        sub_process.send_signal(signal.CTRL_C_EVENT)
                    else:
                        sub_process.send_signal(signal.SIGINT)
                    continue_process_stdout = False
            if line.find("E/AndroidRuntime") != -1:
                sys.stdout.write(line)
                sys.stdout.flush()
            if line.find("Force finishing activity com.dava.unittests") != -1 or \
               line.find("end=assert=msg") != -1:
                app_exit_code = 1
                sys.stdout.write(line)
                sys.stdout.flush()
                
                if start_on_android:
                    # we want to exit from logcat process because sub_process.stdout.readline() will block
                    # current thread
                    if sys.platform == "win32":
                        sub_process.send_signal(signal.CTRL_C_EVENT)
                    else:
                        sub_process.send_signal(signal.SIGINT)
                    continue_process_stdout = False
        else:
            continue_process_stdout = False
    except IOError as err:
        sys.stdout.write(err.message)
        sys.stdout.flush()


if sys.platform == "darwin" and start_on_ios == False and start_on_android == False:
    pathCoverageDir      = os.path.realpath( os.path.join(DAVA_ROOT, 'RepoTools', 'coverage') )
    pathHtmlReportScript = os.path.join( pathCoverageDir, 'coverage_report.py' )   
    pathBuild            = DAVA_BUILD_DIR
    pathExecut           = os.path.realpath( os.path.join( os.getcwd(), '{0}.app'.format( PRJ_NAME_BASE ) ) )
    pathReportOut        = os.path.join( pathBuild, 'Coverage')    

    params = [  'python', pathHtmlReportScript,
                '--pathBuild', pathBuild,  
                '--pathExecut', pathExecut,                   
                '--pathReportOut', pathReportOut,
                '--buildConfig', 'Release',
                '--notExecute' , 'true',
                '--teamcityMode' , 'true', 
                '--buildMode', 'true'                
                 ]

    subprocess.call(params)

if app_exit_code == 1:
    sys.exit(app_exit_code)
else:
    sys.exit(sub_process.returncode)